{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/","title":"Digital Garden 🪴"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-11\nupdated: 2023-03-11\ntags:\n  - README\n---\n\n# Digital Garden 🪴\n\nDigital Garden for Volatile Memory\n\n### Usage\n- [[Roam Research]] 스타일의 문서 링크를 지원하는 도구를 사용해요.\n\t- [Roam Research](https://roamresearch.com/)\n\t- [Obsidian](https://obsidian.md/)\n\t- [Foam](https://foambubble.github.io/)\n- `content/` 경로에 컨텐츠를 작성해 주세요.\n\t- 서브디렉토리나 다른 디렉토리는 없어도 괜찮아요!\n\t- 하이퍼텍스트와 연결을 중심으로 작성해 보세요.\n"},{"fields":{"slug":"/engineering/Mob Programming/","title":"Mob Programming"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-11\nupdated: 2023-03-11\ntags:\n  - Agile\n---\n\n# Mob Programming\n\n- 한 명의 드라이버와 여러명의 프로그래머가 하나의 PC로 코딩 또는 문서화 작업을 진행하는 개발 방식\n- 1:1 방식인 페어 프로그래밍(Pair Programming)을 1:N으로 확장시킨 형태이다.\n  - N은 애자일 개발팀 전체 인원수로 팀 전원이 참여한다는 것이 특징이다.\n\n\n## 참조\n- [들어는 보았나 몹 프로그래밍 - 마켓컬리 기술 블로그](https://helloworld.kurly.com/blog/mob-programming/)\n- [페어 프로그래밍을 넘어서 - Mob Programming - More Agile Blog](https://www.moreagile.net/2014/12/mob-programming.html)\n"},{"fields":{"slug":"/patterns/Design Pattern/","title":"Design Pattern"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-18\nupdated: 2023-03-18\ntags:\n    - Design Pattern\n---\n\n## Pattern에 대해서\n- \"모든 패턴은 우리의 환경에서 반복적으로 발생하는 문제를 설명하며, 이 문제에 대해 수백만 번이라도 반복해서 적용할 수 있지만 매번 다른 방법으로 적용할 수 있는 해결책의 핵심을 설명하는 것이다. - Christopher Alexander\"\n- 패턴의 초점은 하나 이상의 반복적인 문제를 해결하는데 효과적이고 공통적인 특정한 해결책이다.\n  - 패턴을 학습할 때 있어서 다음과 같은 특징을 이해해야한다.\n    - `What` : 이 패턴은 무엇인가 \n    - `Why` : 이 패턴으로 어떠한 문제를 해결하는가\n    - `How` : 이 패턴으로 문제를 어떻게 해결하는가\n- 숙련된 설계자에게 패턴의 가치는 새로운 개념을 이해하는 것이 아닌 원활한 의사소통의 수단이다.\n- 어떠한 패턴이 항상 올바른 선택인 경우는 많지 않다, 때문에 패턴을 발견할 때마다 항상 스스로에게 \"이 패턴이 적절하지 않은 때는 언제일까\"라는 질문을 해보자.\n  - 이 질문에 대해서 생각하면 대안이 되는 패턴을 떠올릴 때가 많다.\n- 패턴은 출발점으로 유용하지만 목적지는 아니라는 사실을 명심하자. (패턴은 Silver Bullet이 아니다.)\n- 소프트웨어 개발에서 단 한가지 확실한 것이 있다면 모든 것이 변한다는 사실이다, 때문에 모든 패턴은 미완성이며 각각의 시스템 환경에 맞게 완성하는 것은 개발자의 몫이다."},{"fields":{"slug":"/engineering/Performance Optimizing/","title":"Performance"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-13\nupdated: 2023-03-13\ntags:\n---\n\n# Performance\n\n## 성능 최적화의 딜레마 \n- 기술의 단점 중에서 성능을 이야기하는 것은 아주 특별한 전제를 상세하게 깔고 이야기하지 않으면 아무 의미없다.\n  - JPA는 JDBC보다 평균 10%느리다는 단점이 있다 하지만 개발 생산성을 올려서 비용을 줄일 수 있다. 오히려 줄어든 비용으로 10% 더 성능이 좋은 서버를 사용하면된다.\n  - 추상 클래스를 상속하는 것과 인터페이스를 구현해서 쓰는 것과 그냥 클래스에 모든 구현을 넣는 것을 비교해보면 인터페이스가 가장 느리다. 그렇다고 개발할 때 인터페이스를 사용하지 않는가?\n- 성능을 따져야 하는 상황이 있고, 성능을 고민해야하는 기술이 있긴하다. 하지만 다른 사람들이 많이 사용하는 유명한 기술을 사용하는데 있어서 그런 고민은 시간 낭비일 수 있다.\n  - 대신 서버의 처리 능력이 떨어지는 증상이 보일 때 그런 순간에 파고들 수 있으면 된다. (비싼 APM을 사용하면 어디서 성능이 저하되고 있는지 다 찾아준다, 그 때 대안을 찾아도 늦지 않는다)\n- 대부분의 온라인 서비스에서 성능의 90%는 DB 관련된 부분에서 좌우된다. \n  - 스프링으로 구현된 서버가 CPU 100%에 도달하는 경우 서비스 초대박이 난것이라고 생각하고 서버를 늘리면된다.\n  - DB는 공유 자원인데다가 대체로 느려서 조금만 잘못해도 절대적인 성능에 영향을 주는데 비해서 AOP 같은 기술에 성능을 따지고 있을 시간이 없다.\n    - [JDK Dynamic Proxy vs CGLib Proxy](https://www.youtube.com/watch?v=MFckVKrJLRQ&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC)와 같은 영상이나 글에서 프록시 구현 기술의 성능에 대해 이야기하기도하지만, 나노 세컨 단위의 차이를 가지고 논하는 것은 의미없다.\n  - 일례로 안드로이드 초창기에는 런타임에 오브젝트를 만들지 말라고 모든 클래스 메서드를 `static`으로 만들기도하고 인터페이스 사용도 지양했지만 현재는 기기의 성능이 좋아져서 그러한 이야기가 전혀 없다."},{"fields":{"slug":"/spring/AOP/","title":"AOP"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-13\nupdated: 2023-03-13\ntags:\n---\n\n# AOP\n\n#### Spring Framework의 AOP\n- CGLib은 클래스 프록시를 꼭 해야하는 경우 또는 강제로 설정한 경우만 만들어지고, 인터페이스를 사용하면 JDK 프록시로 만들어진다.\n- Spring AOP의 가장 크리티컬 한 단점은 Self Invocation 문제 즉, 동일 오브젝트 내의 다른 메서드를 호출할 때 AOP가 적용되지 않는다는 문제가 있다.\n  - 그 외에 성능이나 스택 트레이스가 매우 길어진다는 것들은 사소한 문제이다.\n- JDK 프록시, CGLib 프록시 구현은 선택의 문제이고 둘 사이의 큰 성능 차이는 없다.\n  - CGLib의 근본적인 단점은, `final` 클래스를 만들지 못한다는 것\n  - 추가적으로는 CGLib는 네이티브 컴파일이 가장 큰 적인데, GraalVM으로 AOP를 하는데에 가장 큰 장애 포인트이다.\n    - 오죽하면 스프링이 GraalVM 붙이는 작업을 시작한 이래로 CGLib 기본으로 들어가는 @Configuration을 기본으로 전환했다."},{"fields":{"slug":"/test/Presentation Layer Test/","title":"Presentation Layer Test"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-29\nupdated: 2023-03-29\ntags:\n    - Integration Test\n---\n\n# Presentation Layer Test\n\n\n\n## Presentation Layer를 Integration Test로 사용하는 경우\n- Application Layer를 Mocking 하지 않는다.\n- 실제 API를 통해 UseCase를 실행시킨다.\n- Test Container 등을 통해 독립적으로 테스트할 수 있또록 구성한다. (RDB, Redis 등)\n- 외부 API는 Conditional하게 Mocking 할 수 있도록 구성한다. (기본적으로는 단독으로 테스트할 수 있고, 옵셔널하게 외부 API까지 포함해 테스트도 실행할 수 있도록 한다)\n\n\n## Presentation Layer가 독립적으로 Test 되는 경우\n- Presentation Layer를 제외하고 Mocking 한다.\n- 이런 테스트는 RestDocs를 사용하지 않는 경우에는 보통 작성하지 않는다. (실제로 검증할 수 있는 부분이 거의 없기 때문에)\n- 스펙을 변경할 때의 적신호를 보내줄 수 있지만, 이 신호로 변경할 수 있는지 아닌지에 대한 실질적인 신호로 사용하긴 어렵다. (결국은 클라이언트와 서버 간의 규약이기 때문에)\n- API에 대한 테스트는 하지 않지만 Interceptor, Resolver, Filter, Jackson 구성 등에 대한 논리 테스트는 별도로 작성한다.\n  - Filter가 잘 동작하는지 테스트가 아닌, Filter의 내부 동작이 어떤일을 해야하는지에 대한 테스트를 작성한다.\n  - Filter를 직접 사용해서 테스트하기도 하고, Filter가 DI로 로직을 분리해서 구현되고 있다면 Filter가 사용하는 의존성만 테스트한다."},{"fields":{"slug":"/test/Unit Test/","title":"Unit Test"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2023-03-11\nupdated: 2023-03-11\ntags:\n    - Test\n    - Google\n---\n\n## Google 엔지니어는 이렇게 일한다 중\n- 구글이 말하는 단위 테스트는 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 의미한다.\n  - 크기 : 테스트가 소비하는 자원과 수행할 수 있는 작업\n  - 범위 : 테스트가 검증하고자 하는 코드의 양\n  - 단위 테스트는 일반적으로 크기가 작지만 반드시 그러한 것은 아니다.\n- 좁은 범위의 테스트는 독립된 클래스, 메서드 등의 코드 베이스 중 작은 일부 로직틀 테스트하는 것을 의미한다.\n  - 중간 범위 테스트(통합 테스트)는 적은 수의 컴포넌트 사이의 상호작용을 검증하는 것을 의미한다.\n  - 큰 범위의 테스트(E2E 및 시스템 테스트)는 시스템 사이의 상호 작용을 검증하는 것을 의미한다.\n- `@WebMvcTest`를 사용한 테스트는 단위 테스트인가?\n  - 개인적으로는 그렇게 생각하지 않음, 이미 스프링 MVC, WebFlux 등이 주는 기능을 이용해서 Jackson을 비롯한 여러가지 상호작용을 테스트하고 있기 때문"},{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"}]}}}